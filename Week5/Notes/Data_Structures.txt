Stacks and Queues:
    * Queues are one form of abstract data structure
        - FIFO: First in, first out
    * Stacks: opposite
        - LIFO: Last in = first out

Resizing arrays with Malloc:
        // Implements a list of numbers with an array of dynamic size
        int main(void)
        {
            // List of size 3
            int *list = malloc(3 * sizeof(int));
            if (list == NULL)
            {
                return 1;
            }

            // Initialize list of size 3 with numbers
            list[0] = 1;
            list[1] = 2;
            list[2] = 3;

            // List of size 4
            int *tmp = malloc(4 * sizeof(int));
            if (tmp == NULL)
            {
                free(list);
                return 1;
            }

            // Copy list of size 3 into list of size 4
            for (int i = 0; i < 3; i++)
            {
                tmp[i] = list[i];
            }

            // Add number to list of size 4
            tmp[3] = 4;

            // Free list of size 3
            free(list);

            // Remember list of size 4
            list = tmp;

            // Print list
            for (int i = 0; i < 4; i++)
            {
                printf("%i\n", list[i]);
            }

            // Free list
            free(list);
            return 0;
        }


Linked lists:
    * Values dont have to be store consecutively. As long as they're linked, they can be anywhere in mem.
    * Less time.. more mem.
        - Values have to be stored with a pointer to the next value
        - Node: Container for numbers and pointers

    *
    typedef struct node
    {
        int number;
        struct node *next;
    }
    node;

Pointers:
    (The lecture notes pictures help a lot for this part)

    * Would assign a garbage value to list
        node *list;
    * Would assign NULL to list.. correct
        node *list = NULL;
    * Would allocate space for node
        node *n = malloc(sizeof(node));
    * Would go to the number field of where n is pointing and set equal to 1.. works but cryptic.
        (*n).number = 1;
    * Same thing but shortened
        n -> number = 1;
    * For next....
        n -> next = NULL;

    * ORDER FOR UPDATING POINTERS MATTERS
        - If you dont have a temp value like n: Set the new value to point at list before updating list so that you dont lose it.

    * Code that shows this:
        // Prepends numbers to a linked list, using while loop to print
        #include <cs50.h>
        #include <stdio.h>
        #include <stdlib.h>

        typedef struct node
        {
            int number;
            struct node *next;
        }
        node;

        int main(int argc, char *argv[])
        {
            // Memory for numbers
            node *list = NULL;

            // For each command-line argument
            for (int i = 1; i < argc; i++)
            {
                // Convert argument to int
                int number = atoi(argv[i]);

                // Allocate node for number
                node *n = malloc(sizeof(node));
                if (n == NULL)
                {
                    return 1;
                }
                n->number = number;
                n->next = NULL;

                // Prepend node to list
                n->next = list;
                list = n;
            }

            // Print numbers
            node *ptr = list;
            while (ptr != NULL)
            {
                printf("%i\n", ptr->number);
                ptr = ptr->next;
            }

            // Free memory
            ptr = list;
            while (ptr != NULL)
            {
                node *next = ptr->next;
                free(ptr);
                ptr = next;
            }
        }


    * For appending....
        // If list is empty
        if (list == NULL)
        {
            list = n;
        }

        // If number belongs at beginning of list
        else if (n->number < list->number)
        {
            n->next = list;
            list = n;
        }

        // If number belongs later in list
        else
        {
            // Iterate over nodes in list
            for (node *ptr = list; ptr != NULL; ptr = ptr->next)
            {
                // If at end of list
                if (ptr->next == NULL)
                {
                    // Append node
                    ptr->next = n;
                    break;
                }

                // If in middle of list
                if (n->number < ptr->next->number)
                {
                    n->next = ptr->next;
                    ptr->next = n;
                    break;
                }
            }
        }


Trees:
    *A tree splits up the list left and right for easy sortingf

    *Code:
    // Implements a list of numbers as a binary search tree
    #include <stdio.h>
    #include <stdlib.h>

    // Represents a node
    typedef struct node
    {
        int number;
        struct node *left;
        struct node *right;
    }
    node;

    void free_tree(node *root);
    void print_tree(node *root);

    int main(void)
    {
        // Tree of size 0
        node *tree = NULL;

        // Add number to list
        node *n = malloc(sizeof(node));
        if (n == NULL)
        {
            return 1;
        }
        n->number = 2;
        n->left = NULL;
        n->right = NULL;
        tree = n;

        // Add number to list
        n = malloc(sizeof(node));
        if (n == NULL)
        {
            free_tree(tree);
            return 1;
        }
        n->number = 1;
        n->left = NULL;
        n->right = NULL;
        tree->left = n;

        // Add number to list
        n = malloc(sizeof(node));
        if (n == NULL)
        {
            free_tree(tree);
            return 1;
        }
        n->number = 3;
        n->left = NULL;
        n->right = NULL;
        tree->right = n;

        // Print tree
        print_tree(tree);

        // Free tree
        free_tree(tree);
        return 0;
    }

    void free_tree(node *root)
    {
        if (root == NULL)
        {
            return;
        }
        free_tree(root->left);
        free_tree(root->right);
        free(root);
    }

    void print_tree(node *root)
    {
        if (root == NULL)
        {
            return;
        }
        print_tree(root->left);
        printf("%i\n", root->number);
        print_tree(root->right);
    }

Hashing:
    * Hashing: "bucket sorting" a bigger problem into smaller problems.
    * Hasing Table: An array of linked lists
    * A very simple hash funct:

        #include <ctype.h>

        unsigned int hash(const char *word)
        {
            return toupper(word[0]) - 'A';
        }


Tries:
    * Trie: A tree of arrays




